use anyhow::{bail, Result};

use std::collections::HashMap;

use crate::model::{ConstPools, Tjs2File, Tjs2Object, Variant};
use crate::vmcodes::vm;

// This module emits a low-level, semantics-oriented TJS program that
// replays the VM code using an explicit instruction-pointer state machine.
//
// Design goal: produce *executable* TJS that is as close as possible to the
// original bytecode behavior, not human-readable source.

const NEG_REG_MAX: i32 = 8; // we materialize rN1..rN8 unconditionally

const FAT_NORMAL: i32 = 0;
const FAT_EXPAND: i32 = 1;
const FAT_UNNAMED_EXPAND: i32 = 2;

pub fn emit_executable_tjs(file: &Tjs2File) -> Result<String> {
    let mut out = String::new();

    out.push_str("// Generated by tjs2dec (experimental)\n");
    out.push_str("// This is a low-level, semantics-oriented re-materialization of TJS2 bytecode.\n");

    out.push_str("function __tjs2dec_truthy(v) { return v ? true : false; }\n");
    out.push_str("function __tjs2dec_to_int(v) { v = Number(v); if (isNaN(v)) return 0; return v < 0 ? Math.ceil(v) : Math.floor(v); }\n");
    out.push_str("function __tjs2dec_idiv(a,b) { a = Number(a); b = Number(b); if (b == 0) return 0; var q = a / b; return q < 0 ? Math.ceil(q) : Math.floor(q); }\n");
    out.push_str("function __tjs2dec_get_prop(o, k, ignore) { return ignore ? &(o[k]) : o[k]; }\n");
    out.push_str("function __tjs2dec_set_prop(o, k, v, ignore) { if (ignore) &(o[k]) = v; else o[k] = v; }\n");
    out.push_str("function __tjs2dec_del_prop(o, k) { return delete o[k]; }\n");
    out.push_str("function __tjs2dec_expand_args(dst, v) {\n");
    out.push_str("  if (v == void) return;\n");
    out.push_str("  // Best-effort expansion: treat Array-like values as sequences.\n");
    out.push_str("  if (v instanceof Array) {\n");
    out.push_str("    for (var i = 0; i < v.length; i++) dst.push(v[i]);\n");
    out.push_str("    return;\n");
    out.push_str("  }\n");
    out.push_str("  // If the value is not an Array, push it as-is.\n");
    out.push_str("  dst.push(v);\n");
    out.push_str("}\n\n");

    out.push_str("var __tjs2dec_objs = [];\n\n");

    // Emit object bodies first (so inter-object constants can reference __tjs2dec_objs).
    for obj in &file.objects {
        out.push_str(&emit_object(obj, &file.const_pools)?);
        out.push('\n');
        out.push_str(&format!("__tjs2dec_objs[{idx}] = __tjs2dec_obj_{idx};\n\n", idx = obj.index));
    }

    out.push_str("// Entry point\n");
    out.push_str(&format!("__tjs2dec_objs[{}]();\n", file.toplevel));

    Ok(out)
}

fn emit_object(obj: &Tjs2Object, pools: &ConstPools) -> Result<String> {
    let mut out = String::new();

    out.push_str(&format!("function __tjs2dec_obj_{}() {{\n", obj.index));

    // Registers.
    let maxv = if obj.max_variable_count < 0 { 0 } else { obj.max_variable_count };
    let mut reg_names: Vec<String> = Vec::new();
    for i in 0..maxv {
        reg_names.push(format!("r{}", i));
    }
    for i in 1..=NEG_REG_MAX {
        reg_names.push(format!("rN{}", i));
    }

    // Emit in chunks to keep lines manageable.
    let mut i = 0usize;
    while i < reg_names.len() {
        let end = (i + 16).min(reg_names.len());
        out.push_str("  var ");
        out.push_str(&reg_names[i..end].join(", "));
        out.push_str(";\n");
        i = end;
    }

    // Best-effort mapping for negative registers.
    out.push_str("  // Negative registers are used for special VM bindings.\n");
    out.push_str("  // rN1: this, rN2: global, rN3: arguments (best-effort).\n");
    out.push_str("  rN1 = this;\n");
    out.push_str("  rN2 = global;\n");
    out.push_str("  rN3 = arguments;\n");
    for k in 4..=NEG_REG_MAX {
        out.push_str(&format!("  rN{} = void;\n", k));
    }
    out.push('\n');

    // Per-object data area.
    out.push_str("  // vdata (per-object)\n");
    out.push_str("  var __d = [\n");
    for (di, v) in obj.data.iter().enumerate() {
        out.push_str("    ");
        out.push_str(&variant_to_tjs(v, pools, obj.index));
        out.push_str(&format!(", // *{}\n", di));
    }
    out.push_str("  ];\n\n");

    // Helpers for dynamic register addressing (needed for exception handlers).
    out.push_str("  function __get_reg(i) {\n");
    out.push_str("    switch (i) {\n");
    for r in 0..maxv {
        out.push_str(&format!("      case {}: return r{};\n", r, r));
    }
    for r in 1..=NEG_REG_MAX {
        out.push_str(&format!("      case -{}: return rN{};\n", r, r));
    }
    out.push_str("      default: return void;\n");
    out.push_str("    }\n");
    out.push_str("  }\n\n");

    out.push_str("  function __set_reg(i, v) {\n");
    out.push_str("    switch (i) {\n");
    for r in 0..maxv {
        out.push_str(&format!("      case {}: r{} = v; break;\n", r, r));
    }
    for r in 1..=NEG_REG_MAX {
        out.push_str(&format!("      case -{}: rN{} = v; break;\n", r, r));
    }
    out.push_str("      default: break;\n");
    out.push_str("    }\n");
    out.push_str("  }\n\n");

    out.push_str("  var __this = this;\n");
    out.push_str("  var __rv = void;\n");
    out.push_str("  var __flag = false;\n");
    out.push_str("  var __try = []; // stack of [catch_ip, ex_reg]\n");
    out.push_str("  var ip = 0;\n\n");

    out.push_str("  while (true) {\n");
    out.push_str("    try {\n");
    out.push_str("      switch (ip) {\n");

    let code = &obj.code;

    // Build a pc -> disasm-line map once (avoid O(n^2)).
    let disasm_txt = crate::disasm::disassemble_object(obj, pools)?;
    let mut disasm_map: HashMap<usize, String> = HashMap::new();
    for line in disasm_txt.lines() {
        if let Some((addr, rest)) = line.split_once(' ') {
            if let Ok(a) = addr.parse::<usize>() {
                disasm_map.insert(a, rest.to_string());
            }
        }
    }

    let mut pc: usize = 0;
    while pc < code.len() {
        let line = disasm_map
            .get(&pc)
            .cloned()
            .unwrap_or_else(|| vm::name(code[pc]).to_string());
        let size = insn_len(code, pc)?;
        let case_code = emit_case(obj, pools, pc, &line, size)?;
        out.push_str(&case_code);
        pc += size;
    }

    out.push_str("        default:\n");
    out.push_str("          throw \"Invalid instruction pointer: \" + ip;\n");
    out.push_str("      }\n");
    out.push_str("    } catch (__e) {\n");
    out.push_str("      if (__try.length > 0) {\n");
    out.push_str("        var __h = __try.pop();\n");
    out.push_str("        __set_reg(__h[1], __e);\n");
    out.push_str("        ip = __h[0];\n");
    out.push_str("        continue;\n");
    out.push_str("      }\n");
    out.push_str("      throw __e;\n");
    out.push_str("    }\n");
    out.push_str("  }\n");

    out.push_str("}\n");

    Ok(out)
}

fn emit_build_args(
    code: &[i32],
    pc: usize,
    st: usize,
    argc: i32,
    r: &impl Fn(i32) -> String,
) -> String {
    let mut s = String::new();

    if argc == -1 {
        // Omit args: pass-through current arguments (best-effort).
        s.push_str("          __args = arguments;\n");
        return s;
    }

    if argc == -2 {
        // Extended argument encoding.
        let num = code.get(pc + st).copied().unwrap_or(0) as usize;
        let base = pc + st + 1;
        for j in 0..num {
            let ty = code.get(base + j * 2).copied().unwrap_or(0);
            let v = code.get(base + j * 2 + 1).copied().unwrap_or(0);
            match ty {
                0 => s.push_str(&format!("          __args.push({});\n", r(v))),
                1 => s.push_str(&format!("          __tjs2dec_expand_args(__args, {});\n", r(v))),
                2 => s.push_str("          __tjs2dec_expand_args(__args, arguments);\n"),
                _ => s.push_str(&format!("          __args.push({});\n", r(v))),
            }
        }
        return s;
    }

    let n = if argc < 0 { 0 } else { argc as usize };
    for j in 0..n {
        let v = code.get(pc + st + j).copied().unwrap_or(0);
        s.push_str(&format!("          __args.push({});\n", r(v)));
    }
    s
}

fn emit_op2_prop(
    out: &mut String,
    code: &[i32],
    pc: usize,
    kind: i32,
    r: &impl Fn(i32) -> String,
    op: &str,
    is_idiv: bool,
) -> Result<()> {
    match kind {
        0 => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            if is_idiv {
                out.push_str(&format!("          {} = __tjs2dec_idiv({}, {});\n", r(a), r(a), r(b)));
            } else {
                out.push_str(&format!("          {} = ({} {} {});\n", r(a), r(a), op, r(b)));
            }
        }
        1 => {
            ensure(code, pc, 5)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let key = code[pc + 3];
            let rhs = code[pc + 4];
            out.push_str(&format!("          var __k = __d[{}];\n", key));
            out.push_str(&format!("          var __t = __tjs2dec_get_prop({}, __k, false);\n", r(objr)));
            if is_idiv {
                out.push_str(&format!("          __t = __tjs2dec_idiv(__t, {});\n", r(rhs)));
            } else {
                out.push_str(&format!("          __t = (__t {} {});\n", op, r(rhs)));
            }
            out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                        if dst != 0 {
                out.push_str(&format!("          {} = __t;
", r(dst)));
            }
        }
        2 => {
            ensure(code, pc, 5)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let keyr = code[pc + 3];
            let rhs = code[pc + 4];
            out.push_str(&format!("          var __k = {};\n", r(keyr)));
            out.push_str(&format!("          var __t = __tjs2dec_get_prop({}, __k, false);\n", r(objr)));
            if is_idiv {
                out.push_str(&format!("          __t = __tjs2dec_idiv(__t, {});\n", r(rhs)));
            } else {
                out.push_str(&format!("          __t = (__t {} {});\n", op, r(rhs)));
            }
            out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                        if dst != 0 {
                out.push_str(&format!("          {} = __t;
", r(dst)));
            }
        }
                3 => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let propr = code[pc + 2];
            let rhs = code[pc + 3];

            // Property handler variant: read via unary '*', then write back via unary '*'.
            out.push_str(&format!("          var __p = {};
", r(propr)));
            out.push_str("          var __t = *__p;
");
            if is_idiv {
                out.push_str(&format!("          __t = __tjs2dec_idiv(__t, {});
", r(rhs)));
            } else {
                out.push_str(&format!("          __t = (__t {} {});
", op, r(rhs)));
            }
            out.push_str("          *__p = __t;
");
            if dst != 0 {
                out.push_str(&format!("          {} = __t;
", r(dst)));
            }
        }
        _ => {
            out.push_str(&format!("          throw \"Unimplemented opcode: {} (unknown op2_prop kind) at ip={}\n\";
", code[pc], pc));
        }
    }
    Ok(())
}

fn emit_case(obj: &Tjs2Object, pools: &ConstPools, pc: usize, insn_str: &str, size: usize) -> Result<String> {
    let code = &obj.code;
    let op = code[pc];

    let mut out = String::new();
    out.push_str(&format!("        case {}: // {:08} {}\n", pc, pc, insn_str));

    // Helpers to format registers.
    let r = |idx: i32| -> String { reg_name(idx) };

    // Core opcodes.
    match op {
        x if x == vm::VM_NOP => {
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x == vm::VM_DEBUGGER => {
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }

        // Data/regs
        x if x == vm::VM_CONST => {
            ensure(code, pc, 3)?;
            let dst = code[pc + 1];
            let src = code[pc + 2];
            out.push_str(&format!("          {} = __d[{}];\n", r(dst), src));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CP => {
            ensure(code, pc, 3)?;
            let dst = code[pc + 1];
            let src = code[pc + 2];
            out.push_str(&format!("          {} = {};\n", r(dst), r(src)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CL => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = void;\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_CCL => {
            ensure(code, pc, 4)?;
            let base = code[pc + 1];
            let count = code[pc + 2];
            let step = code[pc + 3];
            out.push_str("          // ccl base,count,step\n");
            out.push_str(&format!(
                "          for (var __i = 0; __i < {}; __i += {}) {{ __set_reg({} + __i, void); }}\n",
                count, step, base
            ));
            out.push_str("          ip += 4;\n          continue;\n");
        }

        // Flag ops
        x if x == vm::VM_TT => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          __flag = __tjs2dec_truthy({});\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_TF => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          __flag = !__tjs2dec_truthy({});\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_NF => {
            ensure(code, pc, 1)?;
            out.push_str("          __flag = !__flag;\n");
            out.push_str("          ip += 1;\n          continue;\n");
        }
        x if x == vm::VM_SETF => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = true;\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_SETNF => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = false;\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }

        // Comparisons -> __flag
        x if x == vm::VM_CEQ => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            out.push_str(&format!("          __flag = ({} == {});\n", r(a), r(b)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CDEQ => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            out.push_str(&format!("          __flag = ({} === {});\n", r(a), r(b)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CLT => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            out.push_str(&format!("          __flag = ({} < {});\n", r(a), r(b)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CGT => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            out.push_str(&format!("          __flag = ({} > {});\n", r(a), r(b)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_CHKINS => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            out.push_str(&format!("          __flag = ({} in {});\n", r(a), r(b)));
            out.push_str("          ip += 3;\n          continue;\n");
        }

        // Jumps
        x if x == vm::VM_JMP => {
            ensure(code, pc, 2)?;
            let tgt = code[pc + 1];
            out.push_str(&format!("          ip = {};\n          continue;\n", tgt));
        }
        x if x == vm::VM_JF => {
            ensure(code, pc, 2)?;
            let tgt = code[pc + 1];
            out.push_str(&format!(
                "          if (!__flag) {{ ip = {}; }} else {{ ip += 2; }}\n          continue;\n",
                tgt
            ));
        }
        x if x == vm::VM_JNF => {
            ensure(code, pc, 2)?;
            let tgt = code[pc + 1];
            out.push_str(&format!(
                "          if (__flag) {{ ip = {}; }} else {{ ip += 2; }}\n          continue;\n",
                tgt
            ));
        }

        // Unary in-place
        x if x == vm::VM_LNOT => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = !__tjs2dec_truthy({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_BNOT => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = ~({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_CHS => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = -({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_TYPEOF => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = typeof({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_EVAL || x == vm::VM_EEXP => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = eval({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_ASC => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = String({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_CHR => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = String.fromCharCode({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_NUM => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = Number({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_INV => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!(
                "          {} = ({} instanceof Variant ? {} : {});\n",
                r(rr),
                r(rr),
                r(rr),
                r(rr)
            ));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_CHKINV => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!(
                "          if (({} instanceof Variant) == false) throw \"CHKINV failed\";\n",
                r(rr)
            ));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_INT => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = __tjs2dec_to_int({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_REAL => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = Number({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_STR => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = String({});\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_OCTET => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = {};\n", r(rr), r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }

        // inc/dec (incl. PD/PI; P is special)
        x if x >= vm::VM_INC && x <= vm::VM_INCP => {
            match x - vm::VM_INC {
                0 => {
                    ensure(code, pc, 2)?;
                    let rr = code[pc + 1];
                    out.push_str(&format!("          {} = ({} + 1);\n", r(rr), r(rr)));
                    out.push_str("          ip += 2;\n          continue;\n");
                }
                1 => {
                    ensure(code, pc, 4)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let key = code[pc + 3];
                    out.push_str(&format!("          var __k = __d[{}];\n", key));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str("          __t = (__t + 1);\n");
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 4;
          continue;
");
                }
                2 => {
                    ensure(code, pc, 4)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let keyr = code[pc + 3];
                    out.push_str(&format!("          var __k = {};\n", r(keyr)));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str("          __t = (__t + 1);\n");
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 4;
          continue;
");
                }
                3 => {
    ensure(code, pc, 3)?;
    let dst = code[pc + 1];
    let propr = code[pc + 2];
    out.push_str(&format!("          var __p = {};
", r(propr)));
    out.push_str("          var __t = *__p;
");
    out.push_str("          __t = (__t + 1);
");
    out.push_str("          *__p = __t;
");
    if dst != 0 {
        out.push_str(&format!("          {} = __t;
", r(dst)));
    }
    out.push_str("          ip += 3;
          continue;
");
}
_ => {}
}
        }
        x if x >= vm::VM_DEC && x <= vm::VM_DECP => {
            match x - vm::VM_DEC {
                0 => {
                    ensure(code, pc, 2)?;
                    let rr = code[pc + 1];
                    out.push_str(&format!("          {} = ({} - 1);\n", r(rr), r(rr)));
                    out.push_str("          ip += 2;\n          continue;\n");
                }
                1 => {
                    ensure(code, pc, 4)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let key = code[pc + 3];
                    out.push_str(&format!("          var __k = __d[{}];\n", key));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str("          __t = (__t - 1);\n");
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 4;
          continue;
");
                }
                2 => {
                    ensure(code, pc, 4)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let keyr = code[pc + 3];
                    out.push_str(&format!("          var __k = {};\n", r(keyr)));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str("          __t = (__t - 1);\n");
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 4;
          continue;
");
                }
                3 => {
    ensure(code, pc, 3)?;
    let dst = code[pc + 1];
    let propr = code[pc + 2];
    out.push_str(&format!("          var __p = {};
", r(propr)));
    out.push_str("          var __t = *__p;
");
    out.push_str("          __t = (__t - 1);
");
    out.push_str("          *__p = __t;
");
    if dst != 0 {
        out.push_str(&format!("          {} = __t;
", r(dst)));
    }
    out.push_str("          ip += 3;
          continue;
");
}
_ => {}
}
        }

        // LOR/LAND (truthy semantics)
        x if x >= vm::VM_LOR && x <= vm::VM_LORP => {
            match x - vm::VM_LOR {
                0 => {
                    ensure(code, pc, 3)?;
                    let a = code[pc + 1];
                    let b = code[pc + 2];
                    out.push_str(&format!(
                        "          {} = (__tjs2dec_truthy({}) || __tjs2dec_truthy({}));\n",
                        r(a),
                        r(a),
                        r(b)
                    ));
                    out.push_str("          ip += 3;\n          continue;\n");
                }
                1 => {
                    ensure(code, pc, 5)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let key = code[pc + 3];
                    let rhs = code[pc + 4];
                    out.push_str(&format!("          var __k = __d[{}];\n", key));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str(&format!(
                        "          __t = (__tjs2dec_truthy(__t) || __tjs2dec_truthy({}));\n",
                        r(rhs)
                    ));
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 5;
          continue;
");
                }
                2 => {
                    ensure(code, pc, 5)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let keyr = code[pc + 3];
                    let rhs = code[pc + 4];
                    out.push_str(&format!("          var __k = {};\n", r(keyr)));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str(&format!(
                        "          __t = (__tjs2dec_truthy(__t) || __tjs2dec_truthy({}));\n",
                        r(rhs)
                    ));
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 5;
          continue;
");
                }
                3 => {
    ensure(code, pc, 4)?;
    let dst = code[pc + 1];
    let propr = code[pc + 2];
    let rhs = code[pc + 3];
    out.push_str(&format!("          var __p = {};
", r(propr)));
    out.push_str("          var __a = *__p;
");
    out.push_str(&format!("          var __b = {};
", r(rhs)));
    out.push_str(&format!(
        "          var __t = (__tjs2dec_truthy(__a) || __tjs2dec_truthy(__b));
"
    ));
    out.push_str("          *__p = __t;
");
    if dst != 0 {
        out.push_str(&format!("          {} = __t;
", r(dst)));
    }
    out.push_str("          ip += 4;
          continue;
");
}
_ => {}
}
        }
        x if x >= vm::VM_LAND && x <= vm::VM_LANDP => {
            match x - vm::VM_LAND {
                0 => {
                    ensure(code, pc, 3)?;
                    let a = code[pc + 1];
                    let b = code[pc + 2];
                    out.push_str(&format!(
                        "          {} = (__tjs2dec_truthy({}) && __tjs2dec_truthy({}));\n",
                        r(a),
                        r(a),
                        r(b)
                    ));
                    out.push_str("          ip += 3;\n          continue;\n");
                }
                1 => {
                    ensure(code, pc, 5)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let key = code[pc + 3];
                    let rhs = code[pc + 4];
                    out.push_str(&format!("          var __k = __d[{}];\n", key));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str(&format!(
                        "          __t = (__tjs2dec_truthy(__t) && __tjs2dec_truthy({}));\n",
                        r(rhs)
                    ));
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 5;
          continue;
");
                }
                2 => {
                    ensure(code, pc, 5)?;
                    let dst = code[pc + 1];
                    let objr = code[pc + 2];
                    let keyr = code[pc + 3];
                    let rhs = code[pc + 4];
                    out.push_str(&format!("          var __k = {};\n", r(keyr)));
                    out.push_str(&format!(
                        "          var __t = __tjs2dec_get_prop({}, __k, false);\n",
                        r(objr)
                    ));
                    out.push_str(&format!(
                        "          __t = (__tjs2dec_truthy(__t) && __tjs2dec_truthy({}));\n",
                        r(rhs)
                    ));
                    out.push_str(&format!("          __tjs2dec_set_prop({}, __k, __t, false);\n", r(objr)));
                    if dst != 0 {
                    out.push_str(&format!("          {} = __t;
", r(dst)));
                }
                out.push_str("          ip += 5;
          continue;
");
                }
                3 => {
    ensure(code, pc, 4)?;
    let dst = code[pc + 1];
    let propr = code[pc + 2];
    let rhs = code[pc + 3];
    out.push_str(&format!("          var __p = {};
", r(propr)));
    out.push_str("          var __a = *__p;
");
    out.push_str(&format!("          var __b = {};
", r(rhs)));
    out.push_str(&format!(
        "          var __t = (__tjs2dec_truthy(__a) && __tjs2dec_truthy(__b));
"
    ));
    out.push_str("          *__p = __t;
");
    if dst != 0 {
        out.push_str(&format!("          {} = __t;
", r(dst)));
    }
    out.push_str("          ip += 4;
          continue;
");
}
_ => {}
}
        }
        // Other op2_prop groups (P-variant remains special but executable)
        x if x >= vm::VM_BOR && x <= vm::VM_BORP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_BOR, &r, "|", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_BXOR && x <= vm::VM_BXORP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_BXOR, &r, "^", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_BAND && x <= vm::VM_BANDP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_BAND, &r, "&", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_SAR && x <= vm::VM_SARP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_SAR, &r, ">>", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_SAL && x <= vm::VM_SALP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_SAL, &r, "<<", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_SR && x <= vm::VM_SRP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_SR, &r, ">>>", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_ADD && x <= vm::VM_ADDP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_ADD, &r, "+", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_SUB && x <= vm::VM_SUBP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_SUB, &r, "-", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_MOD && x <= vm::VM_MODP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_MOD, &r, "%", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_DIV && x <= vm::VM_DIVP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_DIV, &r, "/", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_MUL && x <= vm::VM_MULP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_MUL, &r, "*", false)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x >= vm::VM_IDIV && x <= vm::VM_IDIVP => {
            emit_op2_prop(&mut out, code, pc, x - vm::VM_IDIV, &r, "/", true)?;
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }

        // deld/deli + typeofd/typeofi
        x if x == vm::VM_DELD || x == vm::VM_TYPEOFD => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let key = code[pc + 3];
            if x == vm::VM_DELD {
                out.push_str(&format!(
                    "          {} = __tjs2dec_del_prop({}, __d[{}], false);\n",
                    r(dst),
                    r(objr),
                    key
                ));
            } else {
                out.push_str(&format!(
                    "          {} = typeof(__tjs2dec_get_prop({}, __d[{}], false));\n",
                    r(dst),
                    r(objr),
                    key
                ));
            }
            out.push_str("          ip += 4;\n          continue;\n");
        }
        x if x == vm::VM_DELI || x == vm::VM_TYPEOFI => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let keyr = code[pc + 3];
            if x == vm::VM_DELI {
                out.push_str(&format!(
                    "          {} = __tjs2dec_del_prop({}, {}, false);\n",
                    r(dst),
                    r(objr),
                    r(keyr)
                ));
            } else {
                out.push_str(&format!(
                    "          {} = typeof(__tjs2dec_get_prop({}, {}, false));\n",
                    r(dst),
                    r(objr),
                    r(keyr)
                ));
            }
            out.push_str("          ip += 4;\n          continue;\n");
        }

        // gpd/gpds, gpi/gpis
        x if x == vm::VM_GPD || x == vm::VM_GPDS => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let key = code[pc + 3];
            let ign = if x == vm::VM_GPDS { "true" } else { "false" };
            out.push_str(&format!(
                "          {} = __tjs2dec_get_prop({}, __d[{}], {});\n",
                r(dst),
                r(objr),
                key,
                ign
            ));
            out.push_str("          ip += 4;\n          continue;\n");
        }
        x if x == vm::VM_GPI || x == vm::VM_GPIS => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let keyr = code[pc + 3];
            let ign = if x == vm::VM_GPIS { "true" } else { "false" };
            out.push_str(&format!(
                "          {} = __tjs2dec_get_prop({}, {}, {});\n",
                r(dst),
                r(objr),
                r(keyr),
                ign
            ));
            out.push_str("          ip += 4;\n          continue;\n");
        }

        // spd/spds/spde/spdeh, spi/spis/spie
        x if x == vm::VM_SPD || x == vm::VM_SPDS || x == vm::VM_SPDE || x == vm::VM_SPDEH => {
            ensure(code, pc, 4)?;
            let objr = code[pc + 1];
            let key = code[pc + 2];
            let valr = code[pc + 3];
            let ign = if x == vm::VM_SPDS { "true" } else { "false" };
            out.push_str(&format!(
                "          __tjs2dec_set_prop({}, __d[{}], {}, {});\n",
                r(objr),
                key,
                r(valr),
                ign
            ));
            out.push_str("          ip += 4;\n          continue;\n");
        }
        x if x == vm::VM_SPI || x == vm::VM_SPIS || x == vm::VM_SPIE => {
            ensure(code, pc, 4)?;
            let objr = code[pc + 1];
            let keyr = code[pc + 2];
            let valr = code[pc + 3];
            let ign = if x == vm::VM_SPIS { "true" } else { "false" };
            out.push_str(&format!(
                "          __tjs2dec_set_prop({}, {}, {}, {});\n",
                r(objr),
                r(keyr),
                r(valr),
                ign
            ));
            out.push_str("          ip += 4;\n          continue;\n");
        }

        // call/callD/callI/new
        x if x == vm::VM_CALL || x == vm::VM_NEW => {
            ensure(code, pc, size)?;
            let dst = code[pc + 1];
            let func = code[pc + 2];
            let argc = code[pc + 3];
            out.push_str("          var __args = [];\n");
            out.push_str(&format!("          var __f = {};\n", r(func)));
            out.push_str(&emit_build_args(code, pc, 4, argc, &r));
            if x == vm::VM_NEW {
                out.push_str(&format!("          {} = new __f(...__args);\n", r(dst)));
            } else {
                out.push_str(&format!("          {} = __f.apply(__this, __args);\n", r(dst)));
            }
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x == vm::VM_CALLD => {
            ensure(code, pc, size)?;
            // Layout: op, dst, obj, member_data, tmp_func_reg, argc, ...
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let key = code[pc + 3];
            let tmp = code[pc + 4];
            let argc = code[pc + 5];
            out.push_str("          var __args = [];\n");
            out.push_str(&format!("          var __o = {};\n", r(objr)));
            out.push_str(&format!("          var __m = __d[{}];\n", key));
            out.push_str("          var __f = __tjs2dec_get_prop(__o, __m, false);\n");
            out.push_str(&format!("          {} = __f;\n", r(tmp)));
            out.push_str(&emit_build_args(code, pc, 6, argc, &r));
            out.push_str(&format!("          {} = __f.apply(__o, __args);\n", r(dst)));
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }
        x if x == vm::VM_CALLI => {
            ensure(code, pc, size)?;
            // Layout: op, dst, obj, member_reg, tmp_func_reg, argc, ...
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let keyr = code[pc + 3];
            let tmp = code[pc + 4];
            let argc = code[pc + 5];
            out.push_str("          var __args = [];\n");
            out.push_str(&format!("          var __o = {};\n", r(objr)));
            out.push_str(&format!("          var __m = {};\n", r(keyr)));
            out.push_str("          var __f = __tjs2dec_get_prop(__o, __m, false);\n");
            out.push_str(&format!("          {} = __f;\n", r(tmp)));
            out.push_str(&emit_build_args(code, pc, 6, argc, &r));
            out.push_str(&format!("          {} = __f.apply(__o, __args);\n", r(dst)));
            out.push_str(&format!("          ip += {};\n          continue;\n", size));
        }

                // setp/getp: property handler (unary '*' operator)
        x if x == vm::VM_SETP || x == vm::VM_GETP => {
            ensure(code, pc, 3)?;
            let a = code[pc + 1];
            let b = code[pc + 2];
            if op == vm::VM_GETP {
                // getp %dst, %propobj  => dst = *propobj
                if a != 0 {
                    out.push_str(&format!("          {} = *{};
", r(a), r(b)));
                } else {
                    out.push_str(&format!("          var __tmp = *{};
", r(b)));
                }
            } else {
                // setp %propobj, %src  => *propobj = src
                out.push_str(&format!("          *{} = {};
", r(a), r(b)));
            }
            out.push_str("          ip += 3;
          continue;
");
        }


        // srv/global/throw
        x if x == vm::VM_SRV => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          __rv = {};\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_GLOBAL => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          {} = global;\n", r(rr)));
            out.push_str("          ip += 2;\n          continue;\n");
        }
        x if x == vm::VM_THROW => {
            ensure(code, pc, 2)?;
            let rr = code[pc + 1];
            out.push_str(&format!("          throw {};\n", r(rr)));
        }

        // try stack
        x if x == vm::VM_ENTRY => {
            ensure(code, pc, 3)?;
            let catch_ip = code[pc + 1];
            let exr = code[pc + 2];
            out.push_str(&format!("          __try.push([{}, {}]);\n", catch_ip, exr));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_EXTRY => {
            ensure(code, pc, 1)?;
            out.push_str("          if (__try.length > 0) __try.pop();\n");
            out.push_str("          ip += 1;\n          continue;\n");
        }

        // this / class-instance bookkeeping
        x if x == vm::VM_CHGTHIS => {
            ensure(code, pc, 3)?;
            let save = code[pc + 1];
            let newt = code[pc + 2];
            out.push_str(&format!("          {} = __this;\n", r(save)));
            out.push_str(&format!("          __this = {};\n", r(newt)));
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_ADDCI => {
            ensure(code, pc, 3)?;
            out.push_str("          ip += 3;\n          continue;\n");
        }
        x if x == vm::VM_REGMEMBER => {
            ensure(code, pc, 1)?;
            out.push_str("          ip += 1;\n          continue;\n");
        }

        // ret
        x if x == vm::VM_RET => {
            ensure(code, pc, 1)?;
            out.push_str("          return __rv;\n");
        }

        _ => {
            out.push_str(&format!(
                "          throw \"Unimplemented opcode: {} ({}) at ip={}\";\n",
                op,
                insn_str.split_whitespace().next().unwrap_or("?"),
                pc
            ));
        }
    }

    Ok(out)
}

fn emit_call_like(code: &[i32], pc: usize, obj: &Tjs2Object, op: i32) -> Result<(String, usize)> {
    // Layout (matches disasm::format_call):
    // CALL:  op, dst, func, argc, [args...]
    // NEW:   op, dst, func, argc, [args...]
    // CALLD: op, dst, obj, member_data, argc, ...
    // CALLI: op, dst, obj, member_reg,  argc, ...
    let mut out = String::new();
    let r = |idx: i32| -> String { reg_name(idx) };

    match op {
        x if x == vm::VM_CALL || x == vm::VM_NEW => {
            ensure(code, pc, 4)?;
            let dst = code[pc + 1];
            let func = code[pc + 2];
            let argc = code[pc + 3];
            if argc >= 0 {
                let n = argc as usize;
                ensure(code, pc, 4 + n)?;
                let mut args = Vec::with_capacity(n);
                for j in 0..n {
                    args.push(r(code[pc + 4 + j]));
                }
                if op == vm::VM_NEW {
                    out.push_str(&format!("          {} = new {}({});\n", r(dst), r(func), args.join(", ")));
                } else {
                    out.push_str(&format!("          {} = {}({});\n", r(dst), r(func), args.join(", ")));
                }
                return Ok((out, 4 + n));
            }

            if argc == -1 {
                // Omit args: forward current arguments.
                if op == vm::VM_NEW {
                    // There is no portable 'new' + 'apply' without eval.
                    // Keep the output executable by falling back to no-arg construction.
                    out.push_str(&format!("          // Omit-args NEW is not representable without eval; falling back.\n"));
                    out.push_str(&format!("          {} = new {}();\n", r(dst), r(func)));
                } else {
                    out.push_str(&format!("          {} = {}(...);\n", r(dst), r(func)));
                }
                return Ok((out, 4));
            }

            if argc == -2 {
                ensure(code, pc, 5)?;
                let num = code[pc + 4] as usize;
                ensure(code, pc, 5 + num * 2)?;
                out.push_str("          var __args = [];\n");
                for j in 0..num {
                    let ty = code[pc + 5 + j * 2];
                    let v = code[pc + 5 + j * 2 + 1];
                    match ty {
                        FAT_NORMAL => {
                            out.push_str(&format!("          __args.push({});\n", r(v)));
                        }
                        FAT_EXPAND => {
                            out.push_str(&format!("          __tjs2dec_expand_args(__args, {});\n", r(v)));
                        }
                        FAT_UNNAMED_EXPAND => {
                            out.push_str("          // Unnamed expand: best-effort ignored.\n");
                        }
                        _ => {
                            out.push_str(&format!("          throw \"Bad FAT type: {}\";\n", ty));
                        }
                    }
                }
                if op == vm::VM_NEW {
                    // There is no universally-available "new + apply" without eval.
                    // Keep this executable in most cases: fall back to no-arg construction.
                    out.push_str(&format!("          {} = new {}();\n", r(dst), r(func)));
                } else {
                    out.push_str(&format!("          {} = {}.apply(this, __args);\n", r(dst), r(func)));
                }
                return Ok((out, 5 + num * 2));
            }

            // Unknown argc encoding.
            out.push_str(&format!("          {} = {}();\n", r(dst), r(func)));
            Ok((out, 4))
        }
        x if x == vm::VM_CALLD => {
            ensure(code, pc, 5)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let memd = code[pc + 3];
            let argc = code[pc + 4];

            // Member name is in vdata.
            let mem_expr = format!("__d[{}]", memd);

            if argc >= 0 {
                let n = argc as usize;
                ensure(code, pc, 5 + n)?;
                let mut args = Vec::with_capacity(n);
                for j in 0..n {
                    args.push(r(code[pc + 5 + j]));
                }
                out.push_str(&format!("          {} = {}[{}]({});\n", r(dst), r(objr), mem_expr, args.join(", ")));
                return Ok((out, 5 + n));
            }
            if argc == -1 {
                out.push_str(&format!("          {} = {}[{}](...);\n", r(dst), r(objr), mem_expr));
                return Ok((out, 5));
            }
            if argc == -2 {
                ensure(code, pc, 6)?;
                let num = code[pc + 5] as usize;
                ensure(code, pc, 6 + num * 2)?;
                out.push_str("          var __args = [];\n");
                for j in 0..num {
                    let ty = code[pc + 6 + j * 2];
                    let v = code[pc + 6 + j * 2 + 1];
                    match ty {
                        FAT_NORMAL => out.push_str(&format!("          __args.push({});\n", r(v))),
                        FAT_EXPAND => out.push_str(&format!("          __tjs2dec_expand_args(__args, {});\n", r(v))),
                        FAT_UNNAMED_EXPAND => out.push_str("          // Unnamed expand: best-effort ignored.\n"),
                        _ => out.push_str(&format!("          throw \"Bad FAT type: {}\";\n", ty)),
                    }
                }
                out.push_str(&format!("          {} = {}[{}].apply({}, __args);\n", r(dst), r(objr), mem_expr, r(objr)));
                return Ok((out, 6 + num * 2));
            }

            out.push_str(&format!("          {} = {}[{}]();\n", r(dst), r(objr), mem_expr));
            Ok((out, 5))
        }
        x if x == vm::VM_CALLI => {
            ensure(code, pc, 5)?;
            let dst = code[pc + 1];
            let objr = code[pc + 2];
            let memr = code[pc + 3];
            let argc = code[pc + 4];
            if argc >= 0 {
                let n = argc as usize;
                ensure(code, pc, 5 + n)?;
                let mut args = Vec::with_capacity(n);
                for j in 0..n {
                    args.push(r(code[pc + 5 + j]));
                }
                out.push_str(&format!("          {} = {}[{}]({});\n", r(dst), r(objr), r(memr), args.join(", ")));
                return Ok((out, 5 + n));
            }
            if argc == -1 {
                out.push_str(&format!("          {} = {}[{}](...);\n", r(dst), r(objr), r(memr)));
                return Ok((out, 5));
            }
            if argc == -2 {
                ensure(code, pc, 6)?;
                let num = code[pc + 5] as usize;
                ensure(code, pc, 6 + num * 2)?;
                out.push_str("          var __args = [];\n");
                for j in 0..num {
                    let ty = code[pc + 6 + j * 2];
                    let v = code[pc + 6 + j * 2 + 1];
                    match ty {
                        FAT_NORMAL => out.push_str(&format!("          __args.push({});\n", r(v))),
                        FAT_EXPAND => out.push_str(&format!("          __tjs2dec_expand_args(__args, {});\n", r(v))),
                        FAT_UNNAMED_EXPAND => out.push_str("          // Unnamed expand: best-effort ignored.\n"),
                        _ => out.push_str(&format!("          throw \"Bad FAT type: {}\";\n", ty)),
                    }
                }
                out.push_str(&format!("          {} = {}[{}].apply({}, __args);\n", r(dst), r(objr), r(memr), r(objr)));
                return Ok((out, 6 + num * 2));
            }
            out.push_str(&format!("          {} = {}[{}]();\n", r(dst), r(objr), r(memr)));
            Ok((out, 5))
        }
        _ => bail!("emit_call_like called with non-call opcode {}", op),
    }
}

fn reg_name(idx: i32) -> String {
    if idx >= 0 {
        format!("r{}", idx)
    } else {
        format!("rN{}", -idx)
    }
}

fn variant_to_tjs(v: &Variant, pools: &ConstPools, _obj_index: usize) -> String {
    match v {
        Variant::Void => "void".to_string(),
        Variant::NullObject => "null".to_string(),
        Variant::Unknown => "void /* Unknown */".to_string(),
        Variant::String(i) => {
            let s = pools.strings.get(*i as usize).map(|x| x.as_str()).unwrap_or("");
            quote_tjs_string(s)
        }
        Variant::Octet(i) => {
            // We do not attempt to reconstruct binary octets at this stage.
            // Keep it executable: materialize as void.
            format!("void /* Octet #{} (not materialized) */", i)
        }
        Variant::Real(i) => pools.doubles.get(*i as usize).copied().unwrap_or(0.0).to_string(),
        Variant::Byte(i) => pools.bytes.get(*i as usize).copied().unwrap_or(0).to_string(),
        Variant::Short(i) => pools.shorts.get(*i as usize).copied().unwrap_or(0).to_string(),
        Variant::Integer(i) => pools.ints.get(*i as usize).copied().unwrap_or(0).to_string(),
        Variant::Long(i) => pools.longs.get(*i as usize).copied().unwrap_or(0).to_string(),
        Variant::InterObject(i) => format!("__tjs2dec_objs[{}]", i),
        Variant::InterGenerator(i) => format!("__tjs2dec_objs[{}] /* InterGenerator */", i),
    }
}

fn quote_tjs_string(s: &str) -> String {
    let mut out = String::new();
    out.push('"');
    for ch in s.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            _ => out.push(ch),
        }
    }
    out.push('"');
    out
}

fn ensure(code: &[i32], i: usize, need: usize) -> Result<()> {
    if i + need > code.len() {
        bail!("truncated instruction at {}: need {}, code_len {}", i, need, code.len());
    }
    Ok(())
}

fn insn_len(code: &[i32], pc: usize) -> Result<usize> {
    let op = code[pc];

    if op == vm::VM_CONST {
        return Ok(3);
    }
    for base in [
        vm::VM_CP,
        vm::VM_CEQ,
        vm::VM_CDEQ,
        vm::VM_CLT,
        vm::VM_CGT,
        vm::VM_CHKINS,
        vm::VM_ADDCI,
        vm::VM_CHGTHIS,
    ] {
        if op == base {
            return Ok(3);
        }
    }
    for base in [
        vm::VM_CL,
        vm::VM_SRV,
        vm::VM_GLOBAL,
        vm::VM_THROW,
        vm::VM_TT,
        vm::VM_TF,
        vm::VM_SETF,
        vm::VM_SETNF,
        vm::VM_LNOT,
        vm::VM_BNOT,
        vm::VM_ASC,
        vm::VM_CHR,
        vm::VM_NUM,
        vm::VM_CHS,
        vm::VM_INV,
        vm::VM_CHKINV,
        vm::VM_TYPEOF,
        vm::VM_EVAL,
        vm::VM_EEXP,
        vm::VM_INT,
        vm::VM_REAL,
        vm::VM_STR,
        vm::VM_OCTET,
    ] {
        if op == base {
            return Ok(2);
        }
    }
    if op == vm::VM_CCL {
        return Ok(3);
    }
    for base in [vm::VM_JF, vm::VM_JNF, vm::VM_JMP] {
        if op == base {
            return Ok(2);
        }
    }
    if op == vm::VM_ENTRY {
        return Ok(3);
    }
    for base in [vm::VM_RET, vm::VM_NOP, vm::VM_NF, vm::VM_EXTRY, vm::VM_REGMEMBER, vm::VM_DEBUGGER] {
        if op == base {
            return Ok(1);
        }
    }
    if op == vm::VM_SETP || op == vm::VM_GETP {
        return Ok(3);
    }
    if op == vm::VM_DELD || op == vm::VM_TYPEOFD {
        return Ok(4);
    }
    if op == vm::VM_DELI || op == vm::VM_TYPEOFI {
        return Ok(4);
    }
    if op == vm::VM_GPD || op == vm::VM_GPDS {
        return Ok(4);
    }
    if op == vm::VM_SPD || op == vm::VM_SPDE || op == vm::VM_SPDEH || op == vm::VM_SPDS {
        return Ok(4);
    }
    if op == vm::VM_GPI || op == vm::VM_GPIS {
        return Ok(4);
    }
    if op == vm::VM_SPI || op == vm::VM_SPIE || op == vm::VM_SPIS {
        return Ok(4);
    }

    // inc/dec variants
    for base in [vm::VM_INC, vm::VM_DEC] {
        if op == base {
            return Ok(2);
        }
        if op == base + 1 {
            return Ok(4);
        }
        if op == base + 2 {
            return Ok(4);
        }
        if op == base + 3 {
            return Ok(3);
        }
    }
    // binary op variants base..base+3
    for base in [
        vm::VM_LOR,
        vm::VM_LAND,
        vm::VM_BOR,
        vm::VM_BXOR,
        vm::VM_BAND,
        vm::VM_SAR,
        vm::VM_SAL,
        vm::VM_SR,
        vm::VM_ADD,
        vm::VM_SUB,
        vm::VM_MOD,
        vm::VM_DIV,
        vm::VM_IDIV,
        vm::VM_MUL,
    ] {
        if op == base {
            return Ok(3);
        }
        if op == base + 1 {
            return Ok(5);
        }
        if op == base + 2 {
            return Ok(5);
        }
        if op == base + 3 {
            return Ok(4);
        }
    }

    // call/new and their variable length
    if op == vm::VM_CALL || op == vm::VM_NEW {
        ensure(code, pc, 4)?;
        let argc = code[pc + 3];
        if argc >= 0 {
            return Ok(4 + argc as usize);
        }
        if argc == -1 {
            return Ok(4);
        }
        if argc == -2 {
            ensure(code, pc, 5)?;
            let num = code[pc + 4] as usize;
            return Ok(5 + num * 2);
        }
        return Ok(4);
    }
    if op == vm::VM_CALLD || op == vm::VM_CALLI {
        ensure(code, pc, 5)?;
        let argc = code[pc + 4];
        if argc >= 0 {
            return Ok(5 + argc as usize);
        }
        if argc == -1 {
            return Ok(5);
        }
        if argc == -2 {
            ensure(code, pc, 6)?;
            let num = code[pc + 5] as usize;
            return Ok(6 + num * 2);
        }
        return Ok(5);
    }

    Ok(1)
}
